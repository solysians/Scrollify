pragma solidity ^0.8.20;

import "./base/BaseVerifier.sol";

contract TEEVerifier is BaseVerifier {
    address public immutable attestationContract;
    
    constructor(address _attestationContract) {
        attestationContract = _attestationContract;
    }

    /// @notice Verify ownership of data, the _proof prove: 
    ///         1. The pre-image of dataHashes
    /// @param proofs Proof generated by TEE
    function verifyOwnership(
        bytes[] calldata proofs
    ) external pure override returns (OwnershipProofOutput[] memory) {
        OwnershipProofOutput[] memory outputs = new OwnershipProofOutput[](proofs.length);
        for (uint256 i = 0; i < proofs.length; i++) {
            bytes calldata proof = proofs[i];
            // TODO: DataHash is 32 bytes, Proof is xx bytes, check if the proof format is correct
            // require(proof.length >= 32, "Invalid proof length");

            bytes32 dataHash = bytes32(proof[0:32]);
            bytes calldata proofData = proof[32:];

            // TODO: Implement actual verification logic using proofData
            // attestationContract.verifyProof(proofData);
            bool isValid = true; // Placeholder value

            outputs[i] = OwnershipProofOutput(dataHash, isValid);
        }
        return outputs;
    }

    /// @notice Verify data transfer validity, the _proof prove: 
    ///         1. The pre-image of oldDataHashes
    ///         2. The oldKey can decrypt the pre-image and the new key re-encrypt the plaintexts to new ciphertexts
    ///         3. The newKey is encrypted using the receiver's pubKey
    ///         4. The hashes of new ciphertexts is newDataHashes (key to note: TEE could support a private key of the receiver)
    ///         5. The newDataHashes identified ciphertexts are available in the storage: need the signature from the receiver signing oldDataHashes and newDataHashes
    /// @param proof Proof generated by TEE
    function verifyTransferValidity(
        bytes calldata proof
    ) external view override returns (TransferValidityProofOutput memory) {
        // TODO: Implement actual verification logic
        return TransferValidityProofOutput(new bytes32[](0), new bytes32[](0), bytes("null"), bytes("null"), true);
    }
}